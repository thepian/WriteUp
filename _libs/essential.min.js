/*
    Essential JavaScript ‚ùÄ http://essentialjs.com
    Copyright (C) 2011 by Henrik Vendelbo

    This program is free software: you can redistribute it and/or modify it under the terms of
    the GNU Affero General Public License version 3 as published by the Free Software Foundation.

    Additionally,

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software 
    and associated documentation files (the "Software"), to deal in the Software without restriction, 
    including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, 
    subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING 
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
//function Resolver(a,b,c){function e(a,c){var e=b;for(var f=0,g;g=a[f];++f){var h=e;e=e[g];if(e==undefined)switch(c){case undefined:case"generate":e=h[g]=d();break;case"null":return null;case"throw":throw new Error("The '"+g+"' part of '"+a.join(".")+"' couldn't be resolved.")}}return e}function f(a,b,c,d){c[d]=a,a.__generator__==a&&(a.info.symbol=d,a.info["package"]=b.join("."),a.info.within=c)}function g(a,b){return typeof a=="object"?e(a.name.split("."),a.onundefined):e(a.split("."),b)}switch(typeof a){case"undefined":return Resolver.default;case"string":return Resolver[a]==undefined&&(c==undefined&&(c=b,b={}),Resolver[a]=Resolver(b,c),Resolver[a].named=a),Resolver[a]}c=b||{},b=a,a=c.name;var d=c.generator||Generator(Object);return g.named=a,g.namespace=b,g.declare=function(a,b,c){var d=a.split("."),g=d.pop(),h=e(d,c);h[g]===undefined&&f(b,d,h,g)},g.set=function(a,b,c){var d=a.split("."),g=d.pop(),h=e(d,c);f(b,d,h,g)},g.reference=function(a,b){function d(){var a=e(c,b);return a}function g(a){var d=c.pop(),g=e(c,b);c.push(d),f(a,c,g,d)}function h(a){var d=c.pop(),g=e(c,b);c.push(d),g[d]===undefined&&f(a,c,g,d)}var c=a.split(".");return d.set=g,d.get=d,d.declare=h,d},g.override=function(a,b){b=b||{};var c=b.name||this.named;return Resolver[c]=Resolver(a,b),Resolver[c].named=c,Resolver[c]},g}function Generator(a,b){function d(a,b,d,e,f,h,i,j,k,l,m,n){var o;if(g.info.existing){var p=g.info.identifier.apply(g.info,arguments);p in g.info.existing||(o=g.info.existing[p]=o=new g.type),o=g.info.existing[p]}else o=new g.type;o.__context__={generator:g,info:c,args:[a,b,d,e,f,h,i,j,k,l,m,n]};for(var k=0,i;i=c.constructors[k];++k)c.constructors[k].apply(o,o.__context__.args);return delete o.__context__,o}function e(b,c,d,e,f,h,i,j,k,l,m,n){var o=a.apply(g,arguments);return o}function f(){var a=this.__context__.generator.args;for(var b=0,c;c=a[b];++b)c.preset&&(this[c.preset]=arguments[b])}function h(a){for(var b in a)this.prototype[b]=a[b]}function i(a,b,c,d,e,f){if(b==undefined){var g=this.variants[a];if(g.generator)return g.generator;var g=this.variants[""];return g.generator?g.generator:this}var h=b.handlers,i=b.bases;this.variants[a]={func:b,generator:Generator(b),handlers:h||{},bases:i||[],additional:[c,d,e,f]}}function j(){var a=[];a.push("function "),a.push(this.info.package),a.push("."),a.push(this.info.symbol),a.push("(");var b=[];for(var c=0,d;d=this.args[c];++c)b.push(d.name+":"+d.variantName);return a.push(b.join(",")),a.push(")"),a.push(" {"),a.push("<br>  "),a.push("<br>  }"),a.push("<br>  "),a.join("")}function k(a){if(a.singleton)this.info.singleton=!0,this.info.lifecycle=a.lifecycle,this.info.existing={},this.info.identifier=function(){return 0},this.info.restricted||(Generator.restricted.push(g),this.info.restricted=!0);else if(a.identifier){var b=typeof a.identifier=="string"?a.identifier:"identifier";this.info.identifier=this.info.constructors[-1][b],this.info.existing={},this.info.restricted||(Generator.restricted.push(g),this.info.restricted=!0)}else a.size!=undefined&&(this.info.restricted||(Generator.restricted.push(g),this.info.restricted=!0))}if(a.__generator__)return a.__generator__;var c={arguments:{},options:b,constructors:[]},g=function(b){function u(){}var g=b.length-1,h=b[g];typeof h=="function"?h={}:--g,c.options=h;var i=h.alloc===!1?e:d;i.__generator__=i,i.info=c,i.args=h.args||a.args||[];var j=!1;for(var k=0,l;l=i.args[k];++k)l.no=k,c.arguments[l.name]=l,l.preset&&(j=!0);j&&c.constructors.push(f);var m=i.bases=a.bases||[];if(g>0){m=i.bases=[];for(var k=g,l;k>=1&&(l=b[k]);--k)m.push(b[k])}var n=c.constructors;for(var k=0,o;o=m[k];++k){if(o.bases)for(var p=0,q;q=o.bases[p];++p)n.push(o.bases[p]);n.push(o)}n.push(a),n[-1]=a;if(m.length){var r=Generator(m[0]),s=i.prototype=new r.type;for(var k=1,o;o=m[k];++k)for(var t in o.prototype)s[t]=o.prototype[t]}i.type=u,i.type.prototype=i.prototype;for(var t in a.prototype)i.prototype[t]=a.prototype[t];return a.prototype=i.prototype,i}(arguments);return g.mixin=h,g.variant=i,g.variants={},g.toRepr=j,g.restrict=k,a.__generator__=g,g}Resolver.default=Resolver({},{name:"default"}),Resolver.hasGenerator=function(a){return a.__generator__?!0:typeof a=="function"&&typeof a.type=="function"?!0:!1},Generator.restricted=[],function(){function b(a){this.options=a||{},this.name=this.options.name,this.preset=this.options.preset===!0?this.name:this.options.preset}function c(a){this.type=String,this.variantName="String"}function d(a){this.type=Number,this.variantName="Number"}function e(a){this.type=Date,this.variantName="Date"}function f(a){this.type=Boolean,this.variantName="Boolean"}function g(a){this.type=Object,this.variantName="Object"}function h(a){this.type=Array,this.variantName="Array"}function i(){for(var a=0,b;b=Generator.restricted[a];++a)b.info.lifecycle=="page"&&b()}function j(){for(var a=0,b;b=Generator.restricted[a];++a){var c=b.info.constructors[-1].discarded;for(var d in b.info.existing){var e=b.info.existing[d];c&&c.call(b,e)}b.info.constructors[-1].__generator__=undefined,b.__generator__=undefined}}function k(){i()}function l(){}function m(){j()}function n(){var a=navigator.userAgent.toLowerCase(),b=!1;/webkit/.test(a)||/mozilla/.test(a)&&!/(compatible)/.test(a)||/opera/.test(a)?document.addEventListener("DOMContentLoaded",k,!1):b?function(){var a=document.createElement("document:ready");try{a.doScroll("left"),k(),a=null}catch(b){setTimeout(arguments.callee,0)}}():window.onload=k}var a=Resolver("essential",{});a.set("Type",Generator(b)),a.set("StringType",Generator(c,b)),a.namespace.Type.variant("String",a.namespace.StringType),a.set("NumberType",Generator(d,b)),a.namespace.Type.variant("Number",a.namespace.NumberType),a.set("DateType",Generator(e,b)),a.namespace.Type.variant("Date",a.namespace.DateType),a.set("BooleanType",Generator(f,b)),a.namespace.Type.variant("Boolean",a.namespace.BooleanType),a.set("ObjectType",Generator(g,b)),a.namespace.Type.variant("Object",a.namespace.ObjectType),a.set("ArrayType",Generator(h,b)),a.namespace.Type.variant("Array",a.namespace.ArrayType),window.device||(n(),window.addEventListener?window.addEventListener("load",l,!1):window.attachEvent("onload",l),window.addEventListener?window.addEventListener("beforeunload",m,!1):window.attachEvent("onbeforeunload",m))}()
/**
 * @param {Object} ns Namespace base (Optional)
 * " 
 * @param {Object} options Options { generator: function } (Optional) 
 */
function Resolver(name,ns,options)
{
    switch(typeof(name)) {
    case "undefined":
        // Resolver()
        return Resolver.default;
        
    case "string":
        // Resolver("abc")
        // Resolver("abc",{})
        // Resolver("abc",{},{options})
        if (Resolver[name] == undefined) {
            if (options == undefined) { options = ns; ns = {}; }
            Resolver[name] = Resolver(ns,options);
            Resolver[name].named = name;
            }
        return Resolver[name];
    }

    // Resolver({})
    // Resolver({},{options})
    options = ns || {};
    ns = name;
    name = options.name;
    var _generator = options.generator || Generator(Object); //TODO faster default

    function _resolve(names,onundefined) {
        var top = ns;
        for (var j = 0, n; n = names[j]; ++j) {
            var prev_top = top;
            top = top[n];
            if (top == undefined) {
                switch(onundefined) {
                case undefined:
                case "generate":
                    top = prev_top[n] = _generator();
                    break;
                case "null":
                    return null;
                case "throw":
                    throw new Error("The '" + n + "' part of '" + names.join(".") + "' couldn't be resolved.");
                }
            }
        }
        return top;
    }
    
    function _setValue(value,names,base,symbol)
    {
        base[symbol] = value;
        if (value.__generator__ == value) {
            value.info.symbol = symbol;
            value.info["package"] = names.join(".");
            value.info.within = base;
        }
    }

    /**
     * @param name To resolve
     * @param onundefined What to do for undefined symbols ("generate","null","throw")
     */
    function resolve(name,onundefined) {
        if (typeof name == "object") {
            return _resolve(name.name.split("."),name.onundefined);
        }
        else {
            return _resolve(name.split("."),onundefined);
        }
    };

    resolve.named = name;
    resolve.namespace = ns;
    
    resolve.declare = function(name,value,onundefined) 
    {
        var names = name.split(".");
        var symbol = names.pop();
        var base = _resolve(names,onundefined);
        if (base[symbol] === undefined) { 
            _setValue(value,names,base,symbol);
        }
    };

    resolve.set = function(name,value,onundefined) 
    {
        var names = name.split(".");
        var symbol = names.pop();
        var base = _resolve(names,onundefined);
        _setValue(value,names,base,symbol);
    };

    resolve.reference = function(name,onundefined)
    {
        var names = name.split(".");

        function get() {
            var base = _resolve(names,onundefined);
            return base;
        }
        function set(value) {
            var symbol = names.pop();
            var base = _resolve(names,onundefined);
            names.push(symbol);
            _setValue(value,names,base,symbol);
        }
        function declare(value) {
            var symbol = names.pop();
            var base = _resolve(names,onundefined);
            names.push(symbol);
            if (base[symbol] === undefined) _setValue(value,names,base,symbol);
        }
        get.set = set;
        get.get = get;
        get.declare = declare;

        return get;
    };

    resolve.override = function(ns,options)
    {
        options = options || {};
        var name = options.name || this.named; 
        Resolver[name] = Resolver(ns,options);
        Resolver[name].named = name;
        return Resolver[name];
    };

    return resolve;
}
Resolver.default = Resolver({},{ name:"default" });

Resolver.hasGenerator = function(subject) {
    if (subject.__generator__) return true;
    if (typeof subject == "function" && typeof subject.type == "function") return true;
    return false;
};

/**
 * Generator(constr) - get cached or new generator
 * Generator(constr,base1,base2) - define with bases
 * Generator(constr,base,options) - define with options 
 *
 * options { singleton: false, pool: undefined, allocate: true } 
 *
 */
function Generator(mainConstr,options)
{
    if (mainConstr.__generator__) return mainConstr.__generator__;

    var info = {
        arguments: {},
        options: options,
        constructors: []
    };

    function newGenerator(a,b,c,d,e,f,g,h,i,j,k,l) {
        var instance;
        if (generator.info.existing) {
            //TODO perhaps different this pointer
            var id = generator.info.identifier.apply(generator.info,arguments);
            if (! (id in generator.info.existing)) {
                instance = generator.info.existing[id] = instance = new generator.type();
            }
            instance = generator.info.existing[id];
        } else {
            instance = new generator.type();
        }
        
        // constructors
        instance.__context__ = { generator:generator, info:info, args:[a,b,c,d,e,f,g,h,i,j,k,l] }; //TODO inject morphers that change the args for next constructor
        for(var i=0,g; g=info.constructors[i]; ++i) {
            info.constructors[i].apply(instance,instance.__context__.args);
        }
        delete instance.__context__;
        return instance;
    }


    function simpleGenerator(a,b,c,d,e,f,g,h,i,j,k,l) {
        var instance = mainConstr.apply(generator,arguments);
        return instance;
    }

    function presetMembers() {
        var args = this.__context__.generator.args;
        for(var i=0,a; a = args[i]; ++i) if (a.preset) {
            this[a.preset] = arguments[i];
        }
    }
    
    // Make the generator with type annotations
    var generator = (function(args){
        // mark end of constructor arguments
        var last = args.length-1;
        var options = args[last];
        if (typeof options == "function") {
            options = {};
        } else {
            --last;
        }
        info.options = options;

        var generator = options.alloc === false? simpleGenerator : newGenerator;
        generator.__generator__ = generator;
        generator.info = info;

        // arguments planning
        generator.args = options.args || mainConstr.args || [];
        var argsPreset = false;
        for(var i=0,a; a = generator.args[i]; ++i) {
            a.no = i;
            info.arguments[a.name] = a;
            if (a.preset) argsPreset = true;
        }
        if (argsPreset) {
            info.constructors.push(presetMembers)
        }

        // get order of bases and constructors from the main constructor or the arguments
        var bases = generator.bases = mainConstr.bases || [];
        if (last > 0) {
            bases = generator.bases = [];
            for(var i=last,a; (i >= 1) &&(a = args[i]); --i) {
                bases.push(args[i]);
            }
        }   
        var constructors = info.constructors;
        for(var i=0,b; b = bases[i];++i) {
            if (b.bases) {
                for(var j=0,b2; b2 = b.bases[j]; ++j) constructors.push(b.bases[j]);
            }
            constructors.push(b);
        }
        constructors.push(mainConstr);
        constructors[-1] = mainConstr;

        // If we have base classes, make prototype based on their type
        if (bases.length) {
            var base = Generator(bases[0]);
            var p = generator.prototype = new base.type();
            for(var i=1,b; b = bases[i]; ++i) {
                for(var n in b.prototype) p[n] = b.prototype[n]; 
            }
        }

        // simple type with inheritance chain, fresh prototype
        function type() {}
        generator.type = type;
        generator.type.prototype = generator.prototype;

        // migrate prototype
        for(var n in mainConstr.prototype) generator.prototype[n] = mainConstr.prototype[n];
        mainConstr.prototype = generator.prototype;

        
        return generator;
    })(arguments);

    function mixin(mix) {
        for(var n in mix) this.prototype[n] = mix[n];
    }
    generator.mixin = mixin;
    
    function variant(name,variantConstr,v1,v2,v3,v4) {
        if (variantConstr == undefined) { // Lookup the variant generator
            var g = this.variants[name];
            if (g.generator) return g.generator;
            var g = this.variants[""]; // default generator
            if (g.generator) return g.generator;
            return this;            
        } else {    // Set the variant generator
            var handlers = variantConstr.handlers;
            var bases = variantConstr.bases;
            this.variants[name] = { 
                func: variantConstr,
                generator: Generator(variantConstr),
                handlers: handlers || {},
                bases: bases || [],
                additional: [v1,v2,v3,v4] 
            }; 
        }
    }

    // variant get/set function and variants map
    generator.variant = variant;
    generator.variants = {};

    function toRepr() {
        var l = [];
        l.push("function ");
        l.push(this.info.package);
        l.push(".");
        l.push(this.info.symbol);
        l.push("(");
        var ps = [];
        for(var i=0,a; a = this.args[i]; ++i) {
            ps.push(a.name + ":" + a.variantName);
        }
        l.push(ps.join(","))
        l.push(")");
        l.push(" {");
        l.push("<br>  ");
        l.push("<br>  }");
        l.push("<br>  ");
        
        return l.join("");
    }
    generator.toRepr = toRepr;

    function restrict(restrictions) {
        if (restrictions.singleton) {
            this.info.singleton = true;
            this.info.lifecycle = restrictions.lifecycle;
            this.info.existing = {};
            this.info.identifier = function() {
                return 0;
            }
            if (!this.info.restricted) {
                Generator.restricted.push(generator);
                this.info.restricted = true;
            }
        }
        else if (restrictions.identifier) {
            var fn = typeof restrictions.identifier == "string"? restrictions.identifier : "identifier";
            this.info.identifier = this.info.constructors[-1][fn];
            this.info.existing = {};
            if (!this.info.restricted) {
                Generator.restricted.push(generator);
                this.info.restricted = true;
            }
        }
        else if (restrictions.size != undefined) {
            
            if (!this.info.restricted) {
                Generator.restricted.push(generator);
                this.info.restricted = true;
            }
        }
        else {
            //TODO remove from restricted list
        }
    }
    generator.restrict = restrict;

    // Future calls will return this generator
    mainConstr.__generator__ = generator;
        
    return generator;
};

/* List of generators that have been restricted */
Generator.restricted = [];

// types for describing generator arguments and generated properties
(function(){
    var essential = Resolver("essential",{});
    function Type(options) {
        this.options = options || {};
        this.name = this.options.name;
        this.preset = this.options.preset === true? this.name : this.options.preset;
    }
    essential.set("Type",Generator(Type));
    
    function StringType(options) {
        this.type = String;
        this.variantName = "String";
    }
    essential.set("StringType",Generator(StringType,Type));
    essential.namespace.Type.variant("String",essential.namespace.StringType);
        
    function NumberType(options) {
        this.type = Number;
        this.variantName = "Number";
    }
    essential.set("NumberType",Generator(NumberType,Type));
    essential.namespace.Type.variant("Number",essential.namespace.NumberType);
    
    function DateType(options) {
        this.type = Date;
        this.variantName = "Date";
    }
    essential.set("DateType",Generator(DateType,Type));
    essential.namespace.Type.variant("Date",essential.namespace.DateType);
    
    function BooleanType(options) {
        this.type = Boolean;
        this.variantName = "Boolean";
    }
    essential.set("BooleanType",Generator(BooleanType,Type));
    essential.namespace.Type.variant("Boolean",essential.namespace.BooleanType);
    
    function ObjectType(options) {
        this.type = Object;
        this.variantName = "Object";
    }
    essential.set("ObjectType",Generator(ObjectType,Type));
    essential.namespace.Type.variant("Object",essential.namespace.ObjectType);
    
    function ArrayType(options) {
        this.type = Array;
        this.variantName = "Array";
    }
    essential.set("ArrayType",Generator(ArrayType,Type));
    essential.namespace.Type.variant("Array",essential.namespace.ArrayType);
    
    function instantiatePageSingletons()
    {
        for(var i=0,g; g = Generator.restricted[i]; ++i) {
            if (g.info.lifecycle == "page") {
                g();
            }
        }
    }

    function discardRestricted()
    {
        for(var i=0,g; g = Generator.restricted[i]; ++i) {
            var discarded = g.info.constructors[-1].discarded;
            for(var n in g.info.existing) {
                var instance = g.info.existing[n];
                if (discarded) {
                    discarded.call(g,instance);
                }
            }
            g.info.constructors[-1].__generator__ = undefined;
            g.__generator__ = undefined;
        }
    }

    function fireDomReady()
    {
        instantiatePageSingletons();
    }
    function fireLoad()
    {
        
    }
    function fireBeforeUnload()
    {
        discardRestricted();
    }

    function listenForDomReady() 
    {
      var u = navigator.userAgent.toLowerCase();
      var ie = /*@cc_on!@*/false;
      if ((/webkit/.test(u)) || (/mozilla/.test(u) && !/(compatible)/.test(u)) || (/opera/.test(u))) {
        // opera/moz
        document.addEventListener("DOMContentLoaded",fireDomReady,false);
      } else if (ie) {
        // IE
        (function (){ 
          var tempNode = document.createElement('document:ready'); 
          try {
            tempNode.doScroll('left'); 
            fireDomReady(); 
            tempNode = null; 
          } catch(e) { 
            setTimeout(arguments.callee, 0); 
          } 
        })();
      } else {
        window.onload = fireDomReady;
      }
    }

    if (window.device) {
        //TODO PhoneGap support
    }
    else {
        listenForDomReady();        
        if (window.addEventListener) {
            window.addEventListener("load",fireLoad,false);
        } else {
            window.attachEvent("onload",fireLoad);
        }
        if (window.addEventListener) {
            window.addEventListener("beforeunload",fireBeforeUnload,false);
        } else {
            window.attachEvent("onbeforeunload",fireBeforeUnload);
        }
    }
})();

